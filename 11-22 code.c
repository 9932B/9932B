#pragma config(Sensor, dgtl3,  FrontRightS,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  FrontLeftS,     sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  BackRightS,     sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  BackLeftS,      sensorQuadEncoder)
#pragma config(Motor,  port2,           FrontLeft,     tmotorVex393, openLoop)
#pragma config(Motor,  port3,           FrontRight,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           BackRight,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           BackLeft,      tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

task main()
{
int start = 0; //controls the startup of the program
int n = 0; //controls the switching between autonomous and manual control

//encoder storage values for convienence in autonomous mode
int fr;
int fl;
int br;
int bl;

	while(start == 0)
	{
		wait1Msec(0001); //optional cycling delay
		//if button is pressed on controller
		//start = 1
	}

	//Autonomous program:
	//For development refer to the game manual: https://content.vexrobotics.com/docs/vrc-starstruck/VRC-2016-17-Starstruck-Game-Manual-081616.pdf
	//If directions are reversed, first check if encoder pins are plugged in their correct positions. If so, take the negative of encoder values OR motor values, accordingly.

	SensorValue[FrontRightS] = 0; //reseting encoder values to 0
	SensorValue[FrontLeftS] = 0;
	SensorValue[BackRightS] = 0;
	SensorValue[BackLeftS] = 0;

				//move forward sample code segment (checks for front 2 wheels' encoder values, front-wheel-drive):
				while(SensorValue[FrontRightS] < 120) //moves bot forward for 120 cycles, autocorrecting to move straight. Later, we will add a distance value, and an scaling factor will be automatically applied for usability.
				{
						if (SensorValue[FrontRightS] > SensorValue[FrontLeftS])
							{motor[FrontLeft] = 90;
								motor[FrontRight] = 63;}
						if (SensorValue[FrontRightS] < SensorValue[FrontLeftS])
							{motor[FrontLeft] = 63;
								motor[FrontRight] = 90;}
						if (SensorValue[FrontRightS] == SensorValue[FrontLeftS])
							{motor[FrontLeft] = 63;
								motor[FrontRight] = 63;}
				}

			//Be sure to reset encoder values to 0 before proceeding!
			//move backward sample code segment (checks for back 2 wheels' encoder values, rear-wheel-drive):
				while(SensorValue[FrontRightS] > -120)
				{
						if (SensorValue[FrontRightS] > SensorValue[FrontLeftS])
							{motor[FrontLeft] = -63;
								motor[FrontRight] = -90;}
						if (SensorValue[FrontRightS] < SensorValue[FrontLeftS])
							{motor[FrontLeft] = -90;
								motor[FrontRight] = -63;}
						if (SensorValue[FrontRightS] == SensorValue[FrontLeftS])
							{motor[FrontLeft] = -63;
								motor[FrontRight] = -63;}
				}

			//Strafing left (checks for left 2 wheels' encoder values, left-wheel-drive):
				while(SensorValue[FrontLeftS] < 120)
				{
					if(SensorValue[FrontLeftS] > SensorValue[BackLeftS])
					{motor[FrontLeft] = 63;
						motor[BackLeft] = 90;}
					if(SensorValue[FrontLeftS] < SensorValue[BackLeftS])
					{motor[FrontLeft] = 90;
						motor[BackLeft] = 63;}
					if(SensorValue[FrontLeftS] == SensorValue[BackLeftS])
					{motor[FrontLeft] = 63;
						motor[BackLeft] = 63;}
				}



	//After the autonomous program has finished running; waiting to initiate manual controls
	while (n==0) //forever loop until n is changed
	{
			wait1Msec(0001); //optional cycling delay
		  //if button is pressed on controller
			//n = 1;
	}





		/*Control Schematic:
		Left Joystick controls strafing (Channel 4 and 3)
		Channel 1 (Right Joystick Left, Right) Controls turining counterclockwise, and clockwise, respectively.
		*/
		//Adapted From: https://www.vexforum.com/index.php/12370-holonomic-drives-2-0-a-video-tutorial-by-cody/0

							while(n==1) //forever loop
							{

								motor[FrontLeft] = vexRT[Ch3] + vexRT[Ch4] + vexRT[Ch1];
								motor[FrontRight] = vexRT[Ch3] - vexRT[Ch4] - vexRT[Ch1];
								motor[BackLeft] = -vexRT[Ch3] + vexRT[Ch4] - vexRT[Ch1];
								motor[BackRight]= vexRT[Ch3] + vexRT[Ch4] - vexRT[Ch1];


							}


}
